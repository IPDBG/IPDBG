//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ------------------------------------------------------------------
//   ALL RIGHTS RESERVED
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user’s design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//
//      Project:           plat_01
//      File:              plat_01.v
//      Date:              Mi, 9 Jan 2019 10:17:11 MEZ
//      Version:           2.1
//      Targeted Family:   All
//
//   =======================================================================

`include "system_conf.v"
module arbiter2
#(
	parameter MAX_DAT_WIDTH = 32,
	parameter WBS_DAT_WIDTH = 32,
	parameter WBM0_DAT_WIDTH = 32,
	parameter WBM1_DAT_WIDTH = 32
)(
	// Multiple Master Port0
	WBM0_ADR_O,
	WBM0_DAT_O,
	WBM0_DAT_I,
	WBM0_SEL_O,
	WBM0_WE_O,
	WBM0_ACK_I,
	WBM0_ERR_I,
	WBM0_RTY_I,
	WBM0_CTI_O,
	WBM0_BTE_O,
	WBM0_LOCK_O,
	WBM0_CYC_O,
	WBM0_STB_O,
	// Multiple Master Port1
	WBM1_ADR_O,
	WBM1_DAT_O,
	WBM1_DAT_I,
	WBM1_SEL_O,
	WBM1_WE_O,
	WBM1_ACK_I,
	WBM1_ERR_I,
	WBM1_RTY_I,
	WBM1_CTI_O,
	WBM1_BTE_O,
	WBM1_LOCK_O,
	WBM1_CYC_O,
	WBM1_STB_O,
	// Single Slave Port
	WBS_ADR_I,
	WBS_DAT_I,
	WBS_DAT_O,
	WBS_SEL_I,
	WBS_WE_I,
	WBS_ACK_O,
	WBS_ERR_O,
	WBS_RTY_O,
	WBS_CTI_I,
	WBS_BTE_I,
	WBS_LOCK_I,
	WBS_CYC_I,
	WBS_STB_I,

	clk,
	reset
);

input clk, reset;
input [31:0]WBM0_ADR_O;
input [WBM0_DAT_WIDTH-1:0] WBM0_DAT_O;
output [WBM0_DAT_WIDTH-1:0] WBM0_DAT_I;
input [WBM0_DAT_WIDTH/8-1:0] WBM0_SEL_O;
input  WBM0_WE_O;
output  WBM0_ACK_I;
output  WBM0_ERR_I;
output  WBM0_RTY_I;
input [2:0]WBM0_CTI_O;
input [1:0]WBM0_BTE_O;
input  WBM0_LOCK_O;
input  WBM0_CYC_O;
input  WBM0_STB_O;
input [31:0]WBM1_ADR_O;
input [WBM1_DAT_WIDTH-1:0] WBM1_DAT_O;
output [WBM1_DAT_WIDTH-1:0] WBM1_DAT_I;
input [WBM1_DAT_WIDTH/8-1:0] WBM1_SEL_O;
input  WBM1_WE_O;
output  WBM1_ACK_I;
output  WBM1_ERR_I;
output  WBM1_RTY_I;
input [2:0]WBM1_CTI_O;
input [1:0]WBM1_BTE_O;
input  WBM1_LOCK_O;
input  WBM1_CYC_O;
input  WBM1_STB_O;
output [31:0]WBS_ADR_I;
output [WBS_DAT_WIDTH-1:0] WBS_DAT_I;
input [WBS_DAT_WIDTH-1:0] WBS_DAT_O;
output [WBS_DAT_WIDTH/8-1:0] WBS_SEL_I;
output  WBS_WE_I;
input  WBS_ACK_O;
input  WBS_ERR_O;
input  WBS_RTY_O;
output [2:0]WBS_CTI_I;
output [1:0]WBS_BTE_I;
output  WBS_LOCK_I;
output  WBS_CYC_I;
output  WBS_STB_I;
wire [MAX_DAT_WIDTH-1:0] WBM0_DAT_I_INT;
wire [MAX_DAT_WIDTH-1:0] WBM0_DAT_O_INT;
wire [MAX_DAT_WIDTH/8-1:0] WBM0_SEL_O_INT;
wire [MAX_DAT_WIDTH-1:0] WBM1_DAT_I_INT;
wire [MAX_DAT_WIDTH-1:0] WBM1_DAT_O_INT;
wire [MAX_DAT_WIDTH/8-1:0] WBM1_SEL_O_INT;
wire [MAX_DAT_WIDTH-1:0] WBS_DAT_O_INT;
wire [MAX_DAT_WIDTH-1:0] WBS_DAT_I_INT;
wire [MAX_DAT_WIDTH/8-1:0] WBS_SEL_I_INT;

generate
	if ((WBS_DAT_WIDTH == 8) && ((WBM0_DAT_WIDTH == 32) || (WBM1_DAT_WIDTH == 32))) begin
		assign WBS_DAT_I = ((WBS_ADR_I[1:0] == 2'b00)
			? WBS_DAT_I_INT[31:24]
			: ((WBS_ADR_I[1:0] == 2'b01)
			? WBS_DAT_I_INT[23:16]
			: ((WBS_ADR_I[1:0] == 2'b10)
			? WBS_DAT_I_INT[15:8]
			: WBS_DAT_I_INT[7:0]
			)));
		assign WBS_SEL_I = ((WBS_ADR_I[1:0] == 2'b00)
			? WBS_SEL_I_INT[3]
			: ((WBS_ADR_I[1:0] == 2'b01)
			? WBS_SEL_I_INT[2]
			: ((WBS_ADR_I[1:0] == 2'b10)
			? WBS_SEL_I_INT[1]
			: WBS_SEL_I_INT[0]
			)));
		assign WBS_DAT_O_INT = {4{WBS_DAT_O}};
	end
	else begin
		assign WBS_DAT_I = WBS_DAT_I_INT;
		assign WBS_SEL_I = WBS_SEL_I_INT;
		assign WBS_DAT_O_INT = WBS_DAT_O;
	end
endgenerate

generate
	if ((WBS_DAT_WIDTH == 32) && (WBM0_DAT_WIDTH == 8)) begin
		assign WBM0_DAT_I = ((WBM0_ADR_O[1:0] == 2'b00)
			? WBM0_DAT_I_INT[31:24]
			: ((WBM0_ADR_O[1:0] == 2'b01)
			? WBM0_DAT_I_INT[23:16]
			: ((WBM0_ADR_O[1:0] == 2'b10)
			? WBM0_DAT_I_INT[15:8]
			: WBM0_DAT_I_INT[7:0]
			)));
		assign WBM0_DAT_O_INT = {4{WBM0_DAT_O}};
		assign WBM0_SEL_O_INT = ((WBM0_ADR_O[1:0] == 2'b00)
			? {WBM0_SEL_O, 3'b000}
			: ((WBM0_ADR_O[1:0] == 2'b01)
			? {1'b0, WBM0_SEL_O, 2'b00}
			: ((WBM0_ADR_O[1:0] == 2'b10)
			? {2'b00, WBM0_SEL_O, 1'b0}
			: {3'b000, WBM0_SEL_O}
			)));
	end
	else if ((WBS_DAT_WIDTH == 8) && (MAX_DAT_WIDTH == 32)) begin
		assign WBM0_DAT_I = WBM0_DAT_I_INT;
		assign WBM0_SEL_O_INT = {4{WBM0_SEL_O}};
		assign WBM0_DAT_O_INT = {4{WBM0_DAT_O}};
	end
	else begin
		assign WBM0_DAT_I = WBM0_DAT_I_INT;
		assign WBM0_SEL_O_INT = WBM0_SEL_O;
		assign WBM0_DAT_O_INT = WBM0_DAT_O;
	end
endgenerate

generate
	if ((WBS_DAT_WIDTH == 32) && (WBM1_DAT_WIDTH == 8)) begin
		assign WBM1_DAT_I = ((WBM1_ADR_O[1:0] == 2'b00)
			? WBM1_DAT_I_INT[31:24]
			: ((WBM1_ADR_O[1:0] == 2'b01)
			? WBM1_DAT_I_INT[23:16]
			: ((WBM1_ADR_O[1:0] == 2'b10)
			? WBM1_DAT_I_INT[15:8]
			: WBM1_DAT_I_INT[7:0]
			)));
		assign WBM1_DAT_O_INT = {4{WBM1_DAT_O}};
		assign WBM1_SEL_O_INT = ((WBM1_ADR_O[1:0] == 2'b00)
			? {WBM1_SEL_O, 3'b000}
			: ((WBM1_ADR_O[1:0] == 2'b01)
			? {1'b0, WBM1_SEL_O, 2'b00}
			: ((WBM1_ADR_O[1:0] == 2'b10)
			? {2'b00, WBM1_SEL_O, 1'b0}
			: {3'b000, WBM1_SEL_O}
			)));
	end
	else if ((WBS_DAT_WIDTH == 8) && (MAX_DAT_WIDTH == 32)) begin
		assign WBM1_DAT_I = WBM1_DAT_I_INT;
		assign WBM1_SEL_O_INT = {4{WBM1_SEL_O}};
		assign WBM1_DAT_O_INT = {4{WBM1_DAT_O}};
	end
	else begin
		assign WBM1_DAT_I = WBM1_DAT_I_INT;
		assign WBM1_SEL_O_INT = WBM1_SEL_O;
		assign WBM1_DAT_O_INT = WBM1_DAT_O;
	end
endgenerate


reg [2-1:0] 		selected; // which master is selected.
reg locked;
always @(posedge clk or posedge reset)
begin
	if (reset) begin
		selected <= #1 0;
		locked   <= #1 0;
	end
	else begin
		if (selected == 0) begin
			if (WBM0_STB_O) begin
				selected <= #1 2'd1;
				locked   <= #1 WBM0_LOCK_O;
			end
			else if (WBM1_STB_O) begin
				selected <= #1 2'd2;
				locked   <= #1 WBM1_LOCK_O;
			end
		end
		else if (selected == 2'd1) begin
			if ((WBS_ACK_O || WBS_ERR_O || locked) && ((WBM0_CTI_O == 3'b000) || (WBM0_CTI_O == 3'b111) || locked) && !WBM0_LOCK_O) begin
				selected <= #1 0;
				locked <= #1 0;
			end
		end
		else if (selected == 2'd2) begin
			if ((WBS_ACK_O || WBS_ERR_O || locked) && ((WBM1_CTI_O == 3'b000) || (WBM1_CTI_O == 3'b111) || locked) && !WBM1_LOCK_O) begin
				selected <= #1 0;
				locked <= #1 0;
			end
		end
	end
end

assign WBS_ADR_I =
	(selected == 2'd1 ? WBM0_ADR_O :
	(selected == 2'd2 ? WBM1_ADR_O :
	0));
assign WBS_DAT_I_INT =
	(selected == 2'd1 ? WBM0_DAT_O_INT :
	(selected == 2'd2 ? WBM1_DAT_O_INT :
	0));
assign WBS_SEL_I_INT =
	(selected == 2'd1 ? WBM0_SEL_O_INT :
	(selected == 2'd2 ? WBM1_SEL_O_INT :
	0));
assign WBS_WE_I =
	(selected == 2'd1 ? WBM0_WE_O :
	(selected == 2'd2 ? WBM1_WE_O :
	0));
assign WBS_CTI_I =
	(selected == 2'd1 ? WBM0_CTI_O :
	(selected == 2'd2 ? WBM1_CTI_O :
	0));
assign WBS_BTE_I =
	(selected == 2'd1 ? WBM0_BTE_O :
	(selected == 2'd2 ? WBM1_BTE_O :
	0));
assign WBS_LOCK_I =
	(selected == 2'd1 ? WBM0_LOCK_O :
	(selected == 2'd2 ? WBM1_LOCK_O :
	0));
assign WBS_CYC_I =
	(selected == 2'd1 ? WBM0_CYC_O :
	(selected == 2'd2 ? WBM1_CYC_O :
	0));
assign WBS_STB_I =
	(selected == 2'd1 ? WBM0_STB_O :
	(selected == 2'd2 ? WBM1_STB_O :
	0));

assign WBM0_DAT_I_INT = WBS_DAT_O_INT;
assign WBM0_ACK_I = (selected == 2'd1 ? WBS_ACK_O : 0);
assign WBM0_ERR_I = (selected == 2'd1 ? WBS_ERR_O : 0);
assign WBM0_RTY_I = (selected == 2'd1 ? WBS_RTY_O : 0);

assign WBM1_DAT_I_INT = WBS_DAT_O_INT;
assign WBM1_ACK_I = (selected == 2'd2 ? WBS_ACK_O : 0);
assign WBM1_ERR_I = (selected == 2'd2 ? WBS_ERR_O : 0);
assign WBM1_RTY_I = (selected == 2'd2 ? WBS_RTY_O : 0);

endmodule

`include "../components/lm32_top/rtl/verilog/lm32_include_all.v"
`include "../components/wb_ebr_ctrl/rtl/verilog/wb_ebr_ctrl.v"
`include "../components/slave_passthru/rtl/verilog/slave_passthru.v"
`include "../components/slave_passthru/rtl/verilog/passthru.v"


module plat_01 (
	clk_i,reset_n
, slave_passthruclk
, slave_passthrurst
, slave_passthruslv_adr
, slave_passthruslv_master_data
, slave_passthruslv_slave_data
, slave_passthruslv_strb
, slave_passthruslv_cyc
, slave_passthruslv_ack
, slave_passthruslv_err
, slave_passthruslv_rty
, slave_passthruslv_sel
, slave_passthruslv_we
, slave_passthruslv_bte
, slave_passthruslv_cti
, slave_passthruslv_lock
, slave_passthruintr_active_high,
, ext_break
);
input	clk_i, reset_n, ext_break;
genvar i;
wire [31:0] zwire = 32'hZZZZZZZZ;
wire [31:0] zerowire = 32'h00000000;
wire [31:0] SHAREDBUS_ADR_I;
wire [31:0] SHAREDBUS_DAT_I;
wire [31:0] SHAREDBUS_DAT_O;
wire [3:0] SHAREDBUS_SEL_I;
wire   SHAREDBUS_WE_I;
wire   SHAREDBUS_ACK_O;
wire   SHAREDBUS_ERR_O;
wire   SHAREDBUS_RTY_O;
wire [2:0] SHAREDBUS_CTI_I;
wire [1:0] SHAREDBUS_BTE_I;
wire   SHAREDBUS_LOCK_I;
wire   SHAREDBUS_CYC_I;
wire   SHAREDBUS_STB_I;
wire SHAREDBUS_en;

wire [31:0] LM32I_ADR_O;
wire [31:0] LM32I_DAT_O;
wire [31:0] LM32I_DAT_I;
wire [3:0] LM32I_SEL_O;
wire   LM32I_WE_O;
wire   LM32I_ACK_I;
wire   LM32I_ERR_I;
wire   LM32I_RTY_I;
wire [2:0] LM32I_CTI_O;
wire [1:0] LM32I_BTE_O;
wire   LM32I_LOCK_O;
wire   LM32I_CYC_O;
wire   LM32I_STB_O;
wire [31:0] LM32D_ADR_O;
wire [31:0] LM32D_DAT_O;
wire [31:0] LM32D_DAT_I;
wire [3:0] LM32D_SEL_O;
wire   LM32D_WE_O;
wire   LM32D_ACK_I;
wire   LM32D_ERR_I;
wire   LM32D_RTY_I;
wire [2:0] LM32D_CTI_O;
wire [1:0] LM32D_BTE_O;
wire   LM32D_LOCK_O;
wire   LM32D_CYC_O;
wire   LM32D_STB_O;
wire [31:0] LM32DEBUG_DAT_O;
wire   LM32DEBUG_ACK_O;
wire   LM32DEBUG_ERR_O;
wire   LM32DEBUG_RTY_O;
wire LM32DEBUG_en;
wire [31:0] LM32interrupt_n;

wire [31:0] ebrEBR_DAT_O;
wire   ebrEBR_ACK_O;
wire   ebrEBR_ERR_O;
wire   ebrEBR_RTY_O;
wire ebrEBR_en;

wire [31:0] gdbstubEBR_DAT_O;
wire   gdbstubEBR_ACK_O;
wire   gdbstubEBR_ERR_O;
wire   gdbstubEBR_RTY_O;
wire gdbstubEBR_en;

wire [31:0] slave_passthruS_DAT_O;
wire   slave_passthruS_ACK_O;
wire   slave_passthruS_ERR_O;
wire   slave_passthruS_RTY_O;
wire slave_passthruS_en;
wire slave_passthruINTR_O;
output  slave_passthruclk;
output  slave_passthrurst;
output [32-1:0] slave_passthruslv_adr;
output [32-1:0] slave_passthruslv_master_data;
input [32-1:0] slave_passthruslv_slave_data;
output  slave_passthruslv_strb;
output  slave_passthruslv_cyc;
input  slave_passthruslv_ack;
input  slave_passthruslv_err;
input  slave_passthruslv_rty;
output [3:0]  slave_passthruslv_sel;
output  slave_passthruslv_we;
output [1:0]  slave_passthruslv_bte;
output [2:0]  slave_passthruslv_cti;
output  slave_passthruslv_lock;
input  slave_passthruintr_active_high;
reg [2:0] counter;
wire sys_reset = !counter[2];
always @(posedge clk_i or negedge reset_n)
if (reset_n == 1'b0)
counter <= #1 3'b000;
else
if (counter[2] == 1'b0)
counter <= #1 counter + 1'b1;


wire one_zero = 1'b0;
wire[1:0] two_zero = 2'b00;
wire[2:0] three_zero = 3'b000;
wire[3:0] four_zero = 4'b0000;
wire[31:0] thirtytwo_zero = 32'b0000_0000_0000_0000_0000_0000_0000_0000;

arbiter2
#(
.MAX_DAT_WIDTH ( 32 )
,.WBS_DAT_WIDTH ( 32 )
,.WBM0_DAT_WIDTH ( 32 )
,.WBM1_DAT_WIDTH ( 32 )
)
arbiter (
.WBM0_ADR_O(LM32I_ADR_O),
.WBM0_DAT_O(LM32I_DAT_O[31:0]),
.WBM0_DAT_I(LM32I_DAT_I),
.WBM0_SEL_O(LM32I_SEL_O[3:0]),
.WBM0_WE_O(LM32I_WE_O),
.WBM0_ACK_I(LM32I_ACK_I),
.WBM0_ERR_I(LM32I_ERR_I),
.WBM0_RTY_I(LM32I_RTY_I),
.WBM0_CTI_O(LM32I_CTI_O),
.WBM0_BTE_O(LM32I_BTE_O),
.WBM0_LOCK_O(LM32I_LOCK_O),
.WBM0_CYC_O(LM32I_CYC_O),
.WBM0_STB_O(LM32I_STB_O),
.WBM1_ADR_O(LM32D_ADR_O),
.WBM1_DAT_O(LM32D_DAT_O[31:0]),
.WBM1_DAT_I(LM32D_DAT_I),
.WBM1_SEL_O(LM32D_SEL_O[3:0]),
.WBM1_WE_O(LM32D_WE_O),
.WBM1_ACK_I(LM32D_ACK_I),
.WBM1_ERR_I(LM32D_ERR_I),
.WBM1_RTY_I(LM32D_RTY_I),
.WBM1_CTI_O(LM32D_CTI_O),
.WBM1_BTE_O(LM32D_BTE_O),
.WBM1_LOCK_O(LM32D_LOCK_O),
.WBM1_CYC_O(LM32D_CYC_O),
.WBM1_STB_O(LM32D_STB_O),
.WBS_ADR_I(SHAREDBUS_ADR_I[31:0]),
.WBS_DAT_I(SHAREDBUS_DAT_I[31:0]),
.WBS_DAT_O(SHAREDBUS_DAT_O[31:0]),
.WBS_SEL_I(SHAREDBUS_SEL_I[3:0]),
.WBS_WE_I(SHAREDBUS_WE_I),
.WBS_ACK_O(SHAREDBUS_ACK_O),
.WBS_ERR_O(SHAREDBUS_ERR_O),
.WBS_RTY_O(SHAREDBUS_RTY_O),
.WBS_CTI_I(SHAREDBUS_CTI_I),
.WBS_BTE_I(SHAREDBUS_BTE_I),
.WBS_LOCK_I(SHAREDBUS_LOCK_I),
.WBS_CYC_I(SHAREDBUS_CYC_I),
.WBS_STB_I(SHAREDBUS_STB_I),
.clk (clk_i),
.reset (sys_reset));
assign SHAREDBUS_DAT_O =
ebrEBR_en ? ebrEBR_DAT_O :
gdbstubEBR_en ? gdbstubEBR_DAT_O :
slave_passthruS_en ? slave_passthruS_DAT_O :
0;
assign SHAREDBUS_ERR_O = SHAREDBUS_CYC_I & !(
(!ebrEBR_ERR_O & ebrEBR_en) |
(!gdbstubEBR_ERR_O & gdbstubEBR_en) |
(!slave_passthruS_ERR_O & slave_passthruS_en) |
0);
assign SHAREDBUS_ACK_O =
ebrEBR_en ? ebrEBR_ACK_O :
gdbstubEBR_en ? gdbstubEBR_ACK_O :
slave_passthruS_en ? slave_passthruS_ACK_O :
0;
assign SHAREDBUS_RTY_O =
ebrEBR_en ? ebrEBR_RTY_O :
gdbstubEBR_en ? gdbstubEBR_RTY_O :
slave_passthruS_en ? slave_passthruS_RTY_O :
0;
wire [31:0] LM32DEBUG_DAT_I;
assign LM32DEBUG_DAT_I = 0;
wire [3:0] LM32DEBUG_SEL_I;
assign LM32DEBUG_SEL_I = 0;
assign LM32DEBUG_en = 0;
lm32_top
 LM32(
.I_ADR_O(LM32I_ADR_O),
.I_DAT_O(LM32I_DAT_O),
.I_DAT_I(LM32I_DAT_I),
.I_SEL_O(LM32I_SEL_O),
.I_WE_O(LM32I_WE_O),
.I_ACK_I(LM32I_ACK_I),
.I_ERR_I(LM32I_ERR_I),
.I_RTY_I(LM32I_RTY_I),
.I_CTI_O(LM32I_CTI_O),
.I_BTE_O(LM32I_BTE_O),
.I_LOCK_O(LM32I_LOCK_O),
.I_CYC_O(LM32I_CYC_O),
.I_STB_O(LM32I_STB_O),
.D_ADR_O(LM32D_ADR_O),
.D_DAT_O(LM32D_DAT_O),
.D_DAT_I(LM32D_DAT_I),
.D_SEL_O(LM32D_SEL_O),
.D_WE_O(LM32D_WE_O),
.D_ACK_I(LM32D_ACK_I),
.D_ERR_I(LM32D_ERR_I),
.D_RTY_I(LM32D_RTY_I),
.D_CTI_O(LM32D_CTI_O),
.D_BTE_O(LM32D_BTE_O),
.D_LOCK_O(LM32D_LOCK_O),
.D_CYC_O(LM32D_CYC_O),
.D_STB_O(LM32D_STB_O),
.interrupt_n(LM32interrupt_n),
.ext_break(ext_break),
.clk_i (clk_i), .rst_i (sys_reset));


wire [31:0] ebrEBR_DAT_I;
assign ebrEBR_DAT_I = SHAREDBUS_DAT_I[31:0];
wire [3:0] ebrEBR_SEL_I;
assign ebrEBR_SEL_I = SHAREDBUS_SEL_I;
assign ebrEBR_en = ( SHAREDBUS_ADR_I[31:15] == 17'b0000000000000000);
wb_ebr_ctrl
#(
.SIZE(32768),
.EBR_WB_DAT_WIDTH(32),
.INIT_FILE_NAME("D:/LM32/Lm32_xilinx/lm32_code/bin/Release/testProject.vmem"),
.INIT_FILE_FORMAT("hex"))
 ebr(
.EBR_ADR_I(SHAREDBUS_ADR_I[31:0]),
.EBR_DAT_I(ebrEBR_DAT_I[31:0]),
.EBR_DAT_O(ebrEBR_DAT_O[31:0]),
.EBR_SEL_I(ebrEBR_SEL_I[3:0]),
.EBR_WE_I(SHAREDBUS_WE_I),
.EBR_ACK_O(ebrEBR_ACK_O),
.EBR_ERR_O(ebrEBR_ERR_O),
.EBR_RTY_O(ebrEBR_RTY_O),
.EBR_CTI_I(SHAREDBUS_CTI_I),
.EBR_BTE_I(SHAREDBUS_BTE_I),
.EBR_LOCK_I(SHAREDBUS_LOCK_I),
.EBR_CYC_I(SHAREDBUS_CYC_I & ebrEBR_en),
.EBR_STB_I(SHAREDBUS_STB_I & ebrEBR_en),
.CLK_I (clk_i), .RST_I (sys_reset));


wire [31:0] gdbstubEBR_DAT_I;
assign gdbstubEBR_DAT_I = SHAREDBUS_DAT_I[31:0];
wire [3:0] gdbstubEBR_SEL_I;
assign gdbstubEBR_SEL_I = SHAREDBUS_SEL_I;
assign gdbstubEBR_en = ( SHAREDBUS_ADR_I[31:15] == 17'b00000000000000001);
wb_ebr_ctrl
#(
.SIZE(8192),
.EBR_WB_DAT_WIDTH(32),
.INIT_FILE_NAME("D:/LM32/IPDBG/sw/lm32gdbstub/bin/Release/lm32gdbstub.vmem"),
.INIT_FILE_FORMAT("hex"))
 gdbstub(
.EBR_ADR_I(SHAREDBUS_ADR_I[31:0]),
.EBR_DAT_I(gdbstubEBR_DAT_I[31:0]),
.EBR_DAT_O(gdbstubEBR_DAT_O[31:0]),
.EBR_SEL_I(gdbstubEBR_SEL_I[3:0]),
.EBR_WE_I(SHAREDBUS_WE_I),
.EBR_ACK_O(gdbstubEBR_ACK_O),
.EBR_ERR_O(gdbstubEBR_ERR_O),
.EBR_RTY_O(gdbstubEBR_RTY_O),
.EBR_CTI_I(SHAREDBUS_CTI_I),
.EBR_BTE_I(SHAREDBUS_BTE_I),
.EBR_LOCK_I(SHAREDBUS_LOCK_I),
.EBR_CYC_I(SHAREDBUS_CYC_I & gdbstubEBR_en),
.EBR_STB_I(SHAREDBUS_STB_I & gdbstubEBR_en),
.CLK_I (clk_i), .RST_I (sys_reset));

//assign gdbstubEBR_DAT_O = 32'h00000000;
//assign gdbstubEBR_ACK_O = SHAREDBUS_STB_I & gdbstubEBR_en;
//assign EBR_ERR_O = 1'b0;
//assign EBR_RTY_O = 1'b0;

wire [31:0] slave_passthruS_DAT_I;
assign slave_passthruS_DAT_I = SHAREDBUS_DAT_I[31:0];
wire [3:0] slave_passthruS_SEL_I;
assign slave_passthruS_SEL_I = SHAREDBUS_SEL_I;
assign slave_passthruS_en = ( SHAREDBUS_ADR_I[31] == 1'b1);
slave_passthru
#(
.S_WB_DAT_WIDTH(32),
.S_WB_ADR_WIDTH(32))
 slave_passthru(
.S_ADR_I(SHAREDBUS_ADR_I[31:0]),
.S_DAT_I(slave_passthruS_DAT_I[31:0]),
.S_DAT_O(slave_passthruS_DAT_O[31:0]),
.S_SEL_I(slave_passthruS_SEL_I[3:0]),
.S_WE_I(SHAREDBUS_WE_I),
.S_ACK_O(slave_passthruS_ACK_O),
.S_ERR_O(slave_passthruS_ERR_O),
.S_RTY_O(slave_passthruS_RTY_O),
.S_CTI_I(SHAREDBUS_CTI_I),
.S_BTE_I(SHAREDBUS_BTE_I),
.S_LOCK_I(SHAREDBUS_LOCK_I),
.S_CYC_I(SHAREDBUS_CYC_I & slave_passthruS_en),
.S_STB_I(SHAREDBUS_STB_I & slave_passthruS_en),
.clk(slave_passthruclk),
.rst(slave_passthrurst),
.slv_adr(slave_passthruslv_adr),
.slv_master_data(slave_passthruslv_master_data),
.slv_slave_data(slave_passthruslv_slave_data),
.slv_strb(slave_passthruslv_strb),
.slv_cyc(slave_passthruslv_cyc),
.slv_ack(slave_passthruslv_ack),
.slv_err(slave_passthruslv_err),
.slv_rty(slave_passthruslv_rty),
.slv_sel(slave_passthruslv_sel),
.slv_we(slave_passthruslv_we),
.slv_bte(slave_passthruslv_bte),
.slv_cti(slave_passthruslv_cti),
.slv_lock(slave_passthruslv_lock),
.intr_active_high(slave_passthruintr_active_high),
.INTR_O(slave_passthruINTR_O),
.CLK_I(clk_i), .RST_I(sys_reset));


assign LM32interrupt_n[0] = !slave_passthruINTR_O ;
assign LM32interrupt_n[1] = 1;
assign LM32interrupt_n[2] = 1;
assign LM32interrupt_n[3] = 1;
assign LM32interrupt_n[4] = 1;
assign LM32interrupt_n[5] = 1;
assign LM32interrupt_n[6] = 1;
assign LM32interrupt_n[7] = 1;
assign LM32interrupt_n[8] = 1;
assign LM32interrupt_n[9] = 1;
assign LM32interrupt_n[10] = 1;
assign LM32interrupt_n[11] = 1;
assign LM32interrupt_n[12] = 1;
assign LM32interrupt_n[13] = 1;
assign LM32interrupt_n[14] = 1;
assign LM32interrupt_n[15] = 1;
assign LM32interrupt_n[16] = 1;
assign LM32interrupt_n[17] = 1;
assign LM32interrupt_n[18] = 1;
assign LM32interrupt_n[19] = 1;
assign LM32interrupt_n[20] = 1;
assign LM32interrupt_n[21] = 1;
assign LM32interrupt_n[22] = 1;
assign LM32interrupt_n[23] = 1;
assign LM32interrupt_n[24] = 1;
assign LM32interrupt_n[25] = 1;
assign LM32interrupt_n[26] = 1;
assign LM32interrupt_n[27] = 1;
assign LM32interrupt_n[28] = 1;
assign LM32interrupt_n[29] = 1;
assign LM32interrupt_n[30] = 1;
assign LM32interrupt_n[31] = 1;
endmodule
